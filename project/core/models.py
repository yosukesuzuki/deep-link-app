# -*- coding: utf-8 -*-
# core.models

import hashlib
import uuid

from google.appengine.ext import db
from google.appengine.api import memcache
from kay.auth.models import GoogleUser


def clone_entity(e, **extra_args):
    """
    http://stackoverflow.com/questions/2687724/copy-an-entity-in-google-app-engine-datastore-in-python-without-
    knowing-property
    Clones an entity, adding or overriding constructor attributes.

    The cloned entity will have exactly the same property values as the original
    entity, except where overridden. By default it will have no parent entity or
    key name, unless supplied.

    Args:
      e: The entity to clone
      extra_args: Keyword arguments to override from the cloned entity and pass
        to the constructor.
    Returns:
      A cloned, possibly modified, copy of entity e.
    """
    klass = e.__class__
    props = dict((k, v.__get__(e, klass)) for k, v in klass.properties().iteritems())
    props.update(extra_args)
    return klass(**props)


class Article(db.Model):
    title = db.StringProperty()
    updated_at = db.DateTimeProperty(auto_now=True)
    created_at = db.DateTimeProperty(auto_now_add=True)

    def __unicode__(self):
        return self.title


class ShortURLUser(GoogleUser):
    updated_at = db.DateTimeProperty(auto_now=True)
    created_at = db.DateTimeProperty(auto_now_add=True)


class ShortURL(db.Model):
    """
    set key_name from a path generated by ShortURLID.path
    """
    long_url = db.StringProperty(verbose_name='long URL', required=True)
    fallback_url = db.StringProperty(verbose_name='Fallback URL', default='')
    iphone_url = db.StringProperty(verbose_name='iPhone URL', default='')
    ipad_url = db.StringProperty(verbose_name='iPad URL', default='')
    android_url = db.StringProperty(verbose_name='Android URL', default='')
    wp_url = db.StringProperty(verbose_name='WindowsPhone URL', default='')
    firefox_url = db.StringProperty(verbose_name='FireFox URL', default='')
    user_created = db.StringProperty(verbose_name='Key of ShortURLUser', required=True)
    updated_at = db.DateTimeProperty(auto_now=True)
    created_at = db.DateTimeProperty(auto_now_add=True)

    def create(self):
        short_url_id = ShortURLID(long_url=self.long_url)
        short_url_id.put()
        self._key_name = short_url_id.path
        self.put()

    def get_log_entity_key_name(self):
        user = db.get(self.user_created)
        hashed_url = hashlib.sha512(self.long_url).hexdigest()
        log_entity_key_name = user.key().name() + hashed_url
        return log_entity_key_name

    def check_exist_or_create(self):
        """
        :rtype: string
        """
        log_entity_key_name = self.get_log_entity_key_name()
        check_entity = ShortURLCreateLog.get_by_key_name(log_entity_key_name)
        if check_entity is not None:
            # add logic to check the short url exist or not
            if len(check_entity.short_urls) > 0:
                return {'message': 'short url already exists', 'status': 'error', 'code': 409,
                        'path': check_entity.short_urls[0]}
        self.create()
        short_url_create_log = ShortURLCreateLog(key_name=log_entity_key_name, path=self.key().name(),
                                                 long_url=self.long_url,
                                                 user_created=self.user_created, short_urls=[self.key().name()])
        short_url_create_log.put()
        return {'message': 'short url created', 'status': 'success', 'code': 201, 'path': self.key().name()}

    def set_custom_name(self, custom_name, force=False):
        short_url = ShortURL.get_by_key_name(custom_name)
        if (force is False) and (short_url is not None):
            return {'message': 'custom name already exists', 'status': 'error', 'code': 409, 'url': short_url.long_url}
        custom_name_entity = clone_entity(self, key_name=custom_name)
        custom_name_entity.put()
        log_entity_key_name = self.get_log_entity_key_name()
        short_url_create_log = ShortURLCreateLog.get_by_key_name(log_entity_key_name)
        short_urls = short_url_create_log.short_urls
        short_urls.insert(0, custom_name)
        short_url_create_log.short_urls = short_urls
        short_url_create_log.put()
        return {'message': 'short url created', 'status': 'success', 'code': 201, 'path': custom_name, 'force': force}


class ShortURLCreateLog(db.Model):
    """
    key_name = key of user+sha512 of longurl
    """
    path = db.StringProperty(verbose_name='path of short url', required=True)
    long_url = db.StringProperty(verbose_name='long URL', required=True)
    user_created = db.StringProperty(verbose_name='Key of ShortURLUser')
    short_urls = db.StringListProperty(verbose_name='Array, Keys of ShortURL')
    updated_at = db.DateTimeProperty(auto_now=True)
    created_at = db.DateTimeProperty(auto_now_add=True)


class ShortURLID(db.Model):
    long_url = db.StringProperty(verbose_name='long URL', required=True)
    created_at = db.DateTimeProperty(auto_now_add=True)

    KEY_BASE = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    BASE = 62

    @property
    def path(self):
        """Return our path, our base-62 encoded id"""
        if not self.is_saved():
            return None
        nid = self.key().id()
        s = []
        while nid:
            nid, c = divmod(nid, ShortURLID.BASE)
            s.append(ShortURLID.KEY_BASE[c])
        s.reverse()
        return "".join(s)


class ShortURLRule(db.Model):
    long_url = db.StringProperty(verbose_name='long URL', required=True)
    fallback_url = db.StringProperty(verbose_name='Fallback URL')
    iphone_url = db.StringProperty(verbose_name='iPhone URL')
    ipad_url = db.StringProperty(verbose_name='iPad URL')
    android_url = db.StringProperty(verbose_name='Android URL')
    wp_url = db.StringProperty(verbose_name='WindowsPhone URL')
    firefox_url = db.StringProperty(verbose_name='FireFox URL')
    user_created = db.StringProperty(verbose_name='Key of ShortURLUser')
    updated_at = db.DateTimeProperty(auto_now=True)
    created_at = db.DateTimeProperty(auto_now_add=True)


class APIKey(db.Model):
    description = db.StringProperty(verbose_name='Description of usage')
    user_created = db.StringProperty(verbose_name='Key of ShortURLUser', required=True)
    updated_at = db.DateTimeProperty(auto_now=True)
    created_at = db.DateTimeProperty(auto_now_add=True)

    def __unicode__(self):
        return self.key().name()


def create_api_key(user):
    key_name = uuid.uuid4().hex
    user_created = str(user.key())
    entity = APIKey(key_name=key_name, user_created=user_created)
    entity.put()
    memcache_key = 'api-key-%s' % key_name
    memcache.set(memcache_key, key_name)
    return key_name


def validate_api_key(key_name):
    """
    :param key_name: string
    """
    memcache_key = 'api-key-%s' % key_name
    api_key = memcache.get(memcache_key)
    if api_key is not None:
        return True
    api_key_entity = APIKey.get_by_key_name(key_name)
    if api_key_entity is None:
        return False
    memcache.set(memcache_key, key_name)
    return True


def abort_api_key(key_name):
    entity = APIKey.get_by_key_name(key_name)
    entity.delete()
    memcache_key = 'api-key-%s' % key_name
    api_key = memcache.get(memcache_key)
    if api_key is not None:
        memcache.delete(memcache_key)
